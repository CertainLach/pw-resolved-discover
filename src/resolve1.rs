// This code was autogenerated with `dbus-codegen-rust -c blocking --file resolve1.xml`, see https://github.com/diwic/dbus-rs
use dbus;
#[allow(unused_imports)]
use dbus::arg;
use dbus::blocking;

pub trait OrgFreedesktopDBusPeer {
    fn ping(&self) -> Result<(), dbus::Error>;
    fn get_machine_id(&self) -> Result<String, dbus::Error>;
}

impl<'a, T: blocking::BlockingSender, C: ::std::ops::Deref<Target = T>> OrgFreedesktopDBusPeer
    for blocking::Proxy<'a, C>
{
    fn ping(&self) -> Result<(), dbus::Error> {
        self.method_call("org.freedesktop.DBus.Peer", "Ping", ())
    }

    fn get_machine_id(&self) -> Result<String, dbus::Error> {
        self.method_call("org.freedesktop.DBus.Peer", "GetMachineId", ())
            .and_then(|r: (String,)| Ok(r.0))
    }
}

pub trait OrgFreedesktopDBusIntrospectable {
    fn introspect(&self) -> Result<String, dbus::Error>;
}

impl<'a, T: blocking::BlockingSender, C: ::std::ops::Deref<Target = T>>
    OrgFreedesktopDBusIntrospectable for blocking::Proxy<'a, C>
{
    fn introspect(&self) -> Result<String, dbus::Error> {
        self.method_call("org.freedesktop.DBus.Introspectable", "Introspect", ())
            .and_then(|r: (String,)| Ok(r.0))
    }
}

pub trait OrgFreedesktopDBusProperties {
    fn get(
        &self,
        interface_name: &str,
        property_name: &str,
    ) -> Result<arg::Variant<Box<dyn arg::RefArg + 'static>>, dbus::Error>;
    fn get_all(&self, interface_name: &str) -> Result<arg::PropMap, dbus::Error>;
    fn set(
        &self,
        interface_name: &str,
        property_name: &str,
        value: arg::Variant<Box<dyn arg::RefArg>>,
    ) -> Result<(), dbus::Error>;
}

#[derive(Debug)]
pub struct OrgFreedesktopDBusPropertiesPropertiesChanged {
    pub interface_name: String,
    pub changed_properties: arg::PropMap,
    pub invalidated_properties: Vec<String>,
}

impl arg::AppendAll for OrgFreedesktopDBusPropertiesPropertiesChanged {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.interface_name, i);
        arg::RefArg::append(&self.changed_properties, i);
        arg::RefArg::append(&self.invalidated_properties, i);
    }
}

impl arg::ReadAll for OrgFreedesktopDBusPropertiesPropertiesChanged {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgFreedesktopDBusPropertiesPropertiesChanged {
            interface_name: i.read()?,
            changed_properties: i.read()?,
            invalidated_properties: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for OrgFreedesktopDBusPropertiesPropertiesChanged {
    const NAME: &'static str = "PropertiesChanged";
    const INTERFACE: &'static str = "org.freedesktop.DBus.Properties";
}

impl<'a, T: blocking::BlockingSender, C: ::std::ops::Deref<Target = T>> OrgFreedesktopDBusProperties
    for blocking::Proxy<'a, C>
{
    fn get(
        &self,
        interface_name: &str,
        property_name: &str,
    ) -> Result<arg::Variant<Box<dyn arg::RefArg + 'static>>, dbus::Error> {
        self.method_call(
            "org.freedesktop.DBus.Properties",
            "Get",
            (interface_name, property_name),
        )
        .and_then(|r: (arg::Variant<Box<dyn arg::RefArg + 'static>>,)| Ok(r.0))
    }

    fn get_all(&self, interface_name: &str) -> Result<arg::PropMap, dbus::Error> {
        self.method_call(
            "org.freedesktop.DBus.Properties",
            "GetAll",
            (interface_name,),
        )
        .and_then(|r: (arg::PropMap,)| Ok(r.0))
    }

    fn set(
        &self,
        interface_name: &str,
        property_name: &str,
        value: arg::Variant<Box<dyn arg::RefArg>>,
    ) -> Result<(), dbus::Error> {
        self.method_call(
            "org.freedesktop.DBus.Properties",
            "Set",
            (interface_name, property_name, value),
        )
    }
}

pub trait OrgFreedesktopResolve1Manager {
    fn resolve_hostname(
        &self,
        ifindex: i32,
        name: &str,
        family: i32,
        flags: u64,
    ) -> Result<(Vec<(i32, i32, Vec<u8>)>, String, u64), dbus::Error>;
    fn resolve_address(
        &self,
        ifindex: i32,
        family: i32,
        address: Vec<u8>,
        flags: u64,
    ) -> Result<(Vec<(i32, String)>, u64), dbus::Error>;
    fn resolve_record(
        &self,
        ifindex: i32,
        name: &str,
        class: u16,
        type_: u16,
        flags: u64,
    ) -> Result<(Vec<(i32, u16, u16, Vec<u8>)>, u64), dbus::Error>;
    fn resolve_service(
        &self,
        ifindex: i32,
        name: &str,
        type_: &str,
        domain: &str,
        family: i32,
        flags: u64,
    ) -> Result<
        (
            Vec<(u16, u16, u16, String, Vec<(i32, i32, Vec<u8>)>, String)>,
            Vec<Vec<u8>>,
            String,
            String,
            String,
            u64,
        ),
        dbus::Error,
    >;
    fn get_link(&self, ifindex: i32) -> Result<dbus::Path<'static>, dbus::Error>;
    fn set_link_dns(&self, ifindex: i32, addresses: Vec<(i32, Vec<u8>)>)
        -> Result<(), dbus::Error>;
    fn set_link_dnsex(
        &self,
        ifindex: i32,
        addresses: Vec<(i32, Vec<u8>, u16, &str)>,
    ) -> Result<(), dbus::Error>;
    fn set_link_domains(&self, ifindex: i32, domains: Vec<(&str, bool)>)
        -> Result<(), dbus::Error>;
    fn set_link_default_route(&self, ifindex: i32, enable: bool) -> Result<(), dbus::Error>;
    fn set_link_llmnr(&self, ifindex: i32, mode: &str) -> Result<(), dbus::Error>;
    fn set_link_multicast_dns(&self, ifindex: i32, mode: &str) -> Result<(), dbus::Error>;
    fn set_link_dnsover_tls(&self, ifindex: i32, mode: &str) -> Result<(), dbus::Error>;
    fn set_link_dnssec(&self, ifindex: i32, mode: &str) -> Result<(), dbus::Error>;
    fn set_link_dnssecnegative_trust_anchors(
        &self,
        ifindex: i32,
        names: Vec<&str>,
    ) -> Result<(), dbus::Error>;
    fn revert_link(&self, ifindex: i32) -> Result<(), dbus::Error>;
    fn register_service(
        &self,
        name: &str,
        name_template: &str,
        type_: &str,
        service_port: u16,
        service_priority: u16,
        service_weight: u16,
        txt_datas: Vec<::std::collections::HashMap<&str, Vec<u8>>>,
    ) -> Result<dbus::Path<'static>, dbus::Error>;
    fn unregister_service(&self, service_path: dbus::Path) -> Result<(), dbus::Error>;
    fn reset_statistics(&self) -> Result<(), dbus::Error>;
    fn flush_caches(&self) -> Result<(), dbus::Error>;
    fn reset_server_features(&self) -> Result<(), dbus::Error>;
    fn llmnrhostname(&self) -> Result<String, dbus::Error>;
    fn llmnr(&self) -> Result<String, dbus::Error>;
    fn multicast_dns(&self) -> Result<String, dbus::Error>;
    fn dnsover_tls(&self) -> Result<String, dbus::Error>;
    fn dns(&self) -> Result<Vec<(i32, i32, Vec<u8>)>, dbus::Error>;
    fn dnsex(&self) -> Result<Vec<(i32, i32, Vec<u8>, u16, String)>, dbus::Error>;
    fn fallback_dns(&self) -> Result<Vec<(i32, i32, Vec<u8>)>, dbus::Error>;
    fn fallback_dnsex(&self) -> Result<Vec<(i32, i32, Vec<u8>, u16, String)>, dbus::Error>;
    fn current_dnsserver(&self) -> Result<(i32, i32, Vec<u8>), dbus::Error>;
    fn current_dnsserver_ex(&self) -> Result<(i32, i32, Vec<u8>, u16, String), dbus::Error>;
    fn domains(&self) -> Result<Vec<(i32, String, bool)>, dbus::Error>;
    fn transaction_statistics(&self) -> Result<(u64, u64), dbus::Error>;
    fn cache_statistics(&self) -> Result<(u64, u64, u64), dbus::Error>;
    fn dnssec(&self) -> Result<String, dbus::Error>;
    fn dnssecstatistics(&self) -> Result<(u64, u64, u64, u64), dbus::Error>;
    fn dnssecsupported(&self) -> Result<bool, dbus::Error>;
    fn dnssecnegative_trust_anchors(&self) -> Result<Vec<String>, dbus::Error>;
    fn dnsstub_listener(&self) -> Result<String, dbus::Error>;
    fn resolv_conf_mode(&self) -> Result<String, dbus::Error>;
}

impl<'a, T: blocking::BlockingSender, C: ::std::ops::Deref<Target = T>>
    OrgFreedesktopResolve1Manager for blocking::Proxy<'a, C>
{
    fn resolve_hostname(
        &self,
        ifindex: i32,
        name: &str,
        family: i32,
        flags: u64,
    ) -> Result<(Vec<(i32, i32, Vec<u8>)>, String, u64), dbus::Error> {
        self.method_call(
            "org.freedesktop.resolve1.Manager",
            "ResolveHostname",
            (ifindex, name, family, flags),
        )
    }

    fn resolve_address(
        &self,
        ifindex: i32,
        family: i32,
        address: Vec<u8>,
        flags: u64,
    ) -> Result<(Vec<(i32, String)>, u64), dbus::Error> {
        self.method_call(
            "org.freedesktop.resolve1.Manager",
            "ResolveAddress",
            (ifindex, family, address, flags),
        )
    }

    fn resolve_record(
        &self,
        ifindex: i32,
        name: &str,
        class: u16,
        type_: u16,
        flags: u64,
    ) -> Result<(Vec<(i32, u16, u16, Vec<u8>)>, u64), dbus::Error> {
        self.method_call(
            "org.freedesktop.resolve1.Manager",
            "ResolveRecord",
            (ifindex, name, class, type_, flags),
        )
    }

    fn resolve_service(
        &self,
        ifindex: i32,
        name: &str,
        type_: &str,
        domain: &str,
        family: i32,
        flags: u64,
    ) -> Result<
        (
            Vec<(u16, u16, u16, String, Vec<(i32, i32, Vec<u8>)>, String)>,
            Vec<Vec<u8>>,
            String,
            String,
            String,
            u64,
        ),
        dbus::Error,
    > {
        self.method_call(
            "org.freedesktop.resolve1.Manager",
            "ResolveService",
            (ifindex, name, type_, domain, family, flags),
        )
    }

    fn get_link(&self, ifindex: i32) -> Result<dbus::Path<'static>, dbus::Error> {
        self.method_call("org.freedesktop.resolve1.Manager", "GetLink", (ifindex,))
            .and_then(|r: (dbus::Path<'static>,)| Ok(r.0))
    }

    fn set_link_dns(
        &self,
        ifindex: i32,
        addresses: Vec<(i32, Vec<u8>)>,
    ) -> Result<(), dbus::Error> {
        self.method_call(
            "org.freedesktop.resolve1.Manager",
            "SetLinkDNS",
            (ifindex, addresses),
        )
    }

    fn set_link_dnsex(
        &self,
        ifindex: i32,
        addresses: Vec<(i32, Vec<u8>, u16, &str)>,
    ) -> Result<(), dbus::Error> {
        self.method_call(
            "org.freedesktop.resolve1.Manager",
            "SetLinkDNSEx",
            (ifindex, addresses),
        )
    }

    fn set_link_domains(
        &self,
        ifindex: i32,
        domains: Vec<(&str, bool)>,
    ) -> Result<(), dbus::Error> {
        self.method_call(
            "org.freedesktop.resolve1.Manager",
            "SetLinkDomains",
            (ifindex, domains),
        )
    }

    fn set_link_default_route(&self, ifindex: i32, enable: bool) -> Result<(), dbus::Error> {
        self.method_call(
            "org.freedesktop.resolve1.Manager",
            "SetLinkDefaultRoute",
            (ifindex, enable),
        )
    }

    fn set_link_llmnr(&self, ifindex: i32, mode: &str) -> Result<(), dbus::Error> {
        self.method_call(
            "org.freedesktop.resolve1.Manager",
            "SetLinkLLMNR",
            (ifindex, mode),
        )
    }

    fn set_link_multicast_dns(&self, ifindex: i32, mode: &str) -> Result<(), dbus::Error> {
        self.method_call(
            "org.freedesktop.resolve1.Manager",
            "SetLinkMulticastDNS",
            (ifindex, mode),
        )
    }

    fn set_link_dnsover_tls(&self, ifindex: i32, mode: &str) -> Result<(), dbus::Error> {
        self.method_call(
            "org.freedesktop.resolve1.Manager",
            "SetLinkDNSOverTLS",
            (ifindex, mode),
        )
    }

    fn set_link_dnssec(&self, ifindex: i32, mode: &str) -> Result<(), dbus::Error> {
        self.method_call(
            "org.freedesktop.resolve1.Manager",
            "SetLinkDNSSEC",
            (ifindex, mode),
        )
    }

    fn set_link_dnssecnegative_trust_anchors(
        &self,
        ifindex: i32,
        names: Vec<&str>,
    ) -> Result<(), dbus::Error> {
        self.method_call(
            "org.freedesktop.resolve1.Manager",
            "SetLinkDNSSECNegativeTrustAnchors",
            (ifindex, names),
        )
    }

    fn revert_link(&self, ifindex: i32) -> Result<(), dbus::Error> {
        self.method_call("org.freedesktop.resolve1.Manager", "RevertLink", (ifindex,))
    }

    fn register_service(
        &self,
        name: &str,
        name_template: &str,
        type_: &str,
        service_port: u16,
        service_priority: u16,
        service_weight: u16,
        txt_datas: Vec<::std::collections::HashMap<&str, Vec<u8>>>,
    ) -> Result<dbus::Path<'static>, dbus::Error> {
        self.method_call(
            "org.freedesktop.resolve1.Manager",
            "RegisterService",
            (
                name,
                name_template,
                type_,
                service_port,
                service_priority,
                service_weight,
                txt_datas,
            ),
        )
        .and_then(|r: (dbus::Path<'static>,)| Ok(r.0))
    }

    fn unregister_service(&self, service_path: dbus::Path) -> Result<(), dbus::Error> {
        self.method_call(
            "org.freedesktop.resolve1.Manager",
            "UnregisterService",
            (service_path,),
        )
    }

    fn reset_statistics(&self) -> Result<(), dbus::Error> {
        self.method_call("org.freedesktop.resolve1.Manager", "ResetStatistics", ())
    }

    fn flush_caches(&self) -> Result<(), dbus::Error> {
        self.method_call("org.freedesktop.resolve1.Manager", "FlushCaches", ())
    }

    fn reset_server_features(&self) -> Result<(), dbus::Error> {
        self.method_call(
            "org.freedesktop.resolve1.Manager",
            "ResetServerFeatures",
            (),
        )
    }

    fn llmnrhostname(&self) -> Result<String, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.resolve1.Manager",
            "LLMNRHostname",
        )
    }

    fn llmnr(&self) -> Result<String, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.resolve1.Manager",
            "LLMNR",
        )
    }

    fn multicast_dns(&self) -> Result<String, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.resolve1.Manager",
            "MulticastDNS",
        )
    }

    fn dnsover_tls(&self) -> Result<String, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.resolve1.Manager",
            "DNSOverTLS",
        )
    }

    fn dns(&self) -> Result<Vec<(i32, i32, Vec<u8>)>, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.resolve1.Manager",
            "DNS",
        )
    }

    fn dnsex(&self) -> Result<Vec<(i32, i32, Vec<u8>, u16, String)>, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.resolve1.Manager",
            "DNSEx",
        )
    }

    fn fallback_dns(&self) -> Result<Vec<(i32, i32, Vec<u8>)>, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.resolve1.Manager",
            "FallbackDNS",
        )
    }

    fn fallback_dnsex(&self) -> Result<Vec<(i32, i32, Vec<u8>, u16, String)>, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.resolve1.Manager",
            "FallbackDNSEx",
        )
    }

    fn current_dnsserver(&self) -> Result<(i32, i32, Vec<u8>), dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.resolve1.Manager",
            "CurrentDNSServer",
        )
    }

    fn current_dnsserver_ex(&self) -> Result<(i32, i32, Vec<u8>, u16, String), dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.resolve1.Manager",
            "CurrentDNSServerEx",
        )
    }

    fn domains(&self) -> Result<Vec<(i32, String, bool)>, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.resolve1.Manager",
            "Domains",
        )
    }

    fn transaction_statistics(&self) -> Result<(u64, u64), dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.resolve1.Manager",
            "TransactionStatistics",
        )
    }

    fn cache_statistics(&self) -> Result<(u64, u64, u64), dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.resolve1.Manager",
            "CacheStatistics",
        )
    }

    fn dnssec(&self) -> Result<String, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.resolve1.Manager",
            "DNSSEC",
        )
    }

    fn dnssecstatistics(&self) -> Result<(u64, u64, u64, u64), dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.resolve1.Manager",
            "DNSSECStatistics",
        )
    }

    fn dnssecsupported(&self) -> Result<bool, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.resolve1.Manager",
            "DNSSECSupported",
        )
    }

    fn dnssecnegative_trust_anchors(&self) -> Result<Vec<String>, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.resolve1.Manager",
            "DNSSECNegativeTrustAnchors",
        )
    }

    fn dnsstub_listener(&self) -> Result<String, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.resolve1.Manager",
            "DNSStubListener",
        )
    }

    fn resolv_conf_mode(&self) -> Result<String, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(
            &self,
            "org.freedesktop.resolve1.Manager",
            "ResolvConfMode",
        )
    }
}
